package internal

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strconv"

	"github.com/PortNumber53/task-sync/pkg/models"
)

// processAllRubricSetSteps finds and executes all rubric_set steps.
func processAllRubricSetSteps(db *sql.DB, logger *log.Logger) error {
	query := `
		SELECT s.id, s.task_id, s.title, s.settings, t.local_path
		FROM steps s
		JOIN tasks t ON s.task_id = t.id
		WHERE s.settings ? 'rubric_set'
	`
	rows, err := db.Query(query)
	if err != nil {
		return fmt.Errorf("failed to query for rubric_set steps: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		var stepExec models.StepExec
		if err := rows.Scan(&stepExec.StepID, &stepExec.TaskID, &stepExec.Title, &stepExec.Settings, &stepExec.LocalPath); err != nil {
			logger.Printf("failed to scan rubric_set step: %v", err)
			continue
		}

		stepLogger := log.New(os.Stdout, fmt.Sprintf("STEP %d [rubric_set]: ", stepExec.StepID), log.Ldate|log.Ltime|log.Lshortfile)

		if err := ProcessRubricSetStep(db, &stepExec, stepLogger); err != nil {
			logger.Printf("failed to process rubric_set step %d: %v", stepExec.StepID, err)
		}
	}

	return nil
}

// checkForChanges checks for modifications in rubric-related files by comparing their SHA256 hashes.
func checkForChanges(config *models.RubricSetConfig, localPath string, stepLogger *log.Logger) (bool, map[string]string, error) {
	filesToCheck := map[string]string{
		"file":          config.File,
		"held_out_test": config.HeldOutTest,
		"solution_1":    config.Solution1,
		"solution_2":    config.Solution2,
		"solution_3":    config.Solution3,
		"solution_4":    config.Solution4,
	}

	changed := false
	newHashes := make(map[string]string)
	if config.Hashes == nil {
		config.Hashes = make(map[string]string)
	}

	for key, file := range filesToCheck {
		if file == "" {
			continue
		}
		filePath := filepath.Join(localPath, file)
		if _, err := os.Stat(filePath); os.IsNotExist(err) {
			// If a file is optional and doesn't exist, it's not an error.
			// But if it's the main rubric file, it is an error.
			if key == "file" {
				return false, nil, fmt.Errorf("main rubric file does not exist at path: %s", filePath)
			}
			stepLogger.Printf("Optional file not found, skipping: %s", filePath)
			continue
		}

		currentHash, err := models.GetSHA256(filePath)
		if err != nil {
			if err == models.ErrEmptyFile {
				stepLogger.Printf("Warning: %s file is empty, skipping hash check: %s", key, filePath)
				// Treat empty file as "unchanged" unless it was previously not empty.
				if oldHash, ok := config.Hashes[key]; ok && oldHash != "" {
					changed = true
				}
				newHashes[key] = "" // Store empty hash
				continue
			}
			return false, nil, fmt.Errorf("failed to calculate hash for %s: %w", filePath, err)
		}

		if oldHash, ok := config.Hashes[key]; !ok || oldHash != currentHash {
			changed = true
		}
		newHashes[key] = currentHash
	}

	return changed, newHashes, nil
}

// ProcessRubricSetStep handles the execution of a rubric_set step.
// It detects changes in rubric files, parses the main rubric file,
// and then creates, updates, or deletes child rubric_shell steps to match the criteria.
func ProcessRubricSetStep(db *sql.DB, stepExec *models.StepExec, stepLogger *log.Logger) error {
	var settings struct {
		RubricSet models.RubricSetConfig `json:"rubric_set"`
	}
	if err := json.Unmarshal([]byte(stepExec.Settings), &settings); err != nil {
		return fmt.Errorf("failed to unmarshal step settings: %w", err)
	}
	config := &settings.RubricSet

	// 1. Detect changes in any of the rubric-related files.
		_, newHashes, err := checkForChanges(config, stepExec.LocalPath, stepLogger)
	if err != nil {
		return fmt.Errorf("failed to check for file changes: %w", err)
	}
		// Always upsert data for now, even if hashes don't change.
	// if !changed {
	// 	stepLogger.Println("No changes detected in rubric files. Skipping.")
	// 	return nil
	// }
	stepLogger.Println("Changes detected in rubric files. Processing steps.")

	// 2. Parse the main rubric file to get the list of criteria.
	markdownFilePath := filepath.Join(stepExec.LocalPath, config.File)
	criteria, err := models.ParseRubric(markdownFilePath)
	if err != nil {
		return fmt.Errorf("failed to parse rubric markdown: %w", err)
	}
	stepLogger.Printf("Found %d criteria in %s", len(criteria), markdownFilePath)

	// 3. Get all existing rubric_shell steps generated by this rubric_set step.
	existingSteps, err := models.GetGeneratedSteps(db, stepExec.StepID)
	if err != nil {
		return fmt.Errorf("failed to get existing generated steps: %w", err)
	}
	stepLogger.Printf("Found %d existing generated steps.", len(existingSteps))

	// Create a map of existing steps by their criterion ID for efficient lookup and management.
	existingStepsByCriterionID := make(map[string]models.Step)
	for _, step := range existingSteps {
		var stepSettings struct {
			RubricShell models.RubricShellConfig `json:"rubric_shell"`
		}
		if err := json.Unmarshal([]byte(step.Settings), &stepSettings); err != nil {
			stepLogger.Printf("failed to unmarshal rubric_shell settings for step %d, skipping: %v", step.ID, err)
			continue
		}
		if stepSettings.RubricShell.CriterionID != "" {
			existingStepsByCriterionID[stepSettings.RubricShell.CriterionID] = step
		}
	}

	// 4. Process each criterion: update existing steps or create new ones.
	for _, criterion := range criteria {
		title := fmt.Sprintf("Rubric %s: %s", criterion.Counter, criterion.Title)
		rubricShellSettings := models.RubricShellConfig{
			Command:     criterion.HeldOutTest,
			CriterionID: criterion.Title,
			Counter:     criterion.Counter,
			Score:       criterion.Score,
			Required:    criterion.Required,
			DependsOn:   []models.Dependency{{ID: stepExec.StepID}},
			GeneratedBy: strconv.Itoa(stepExec.StepID),
		}

		if existingStep, ok := existingStepsByCriterionID[criterion.Title]; ok {
			// Step exists, check if it needs an update.
			var existingSettings struct {
				RubricShell models.RubricShellConfig `json:"rubric_shell"`
			}
			_ = json.Unmarshal([]byte(existingStep.Settings), &existingSettings) // Error already handled when building map

			needsUpdate := existingStep.Title != title ||
				existingSettings.RubricShell.Command != rubricShellSettings.Command ||
				existingSettings.RubricShell.Score != rubricShellSettings.Score ||
				existingSettings.RubricShell.Required != rubricShellSettings.Required

			if needsUpdate {
				wrappedSettings := map[string]models.RubricShellConfig{"rubric_shell": rubricShellSettings}
				settingsBytes, _ := json.Marshal(wrappedSettings)
				if err := models.UpdateStep(db, existingStep.ID, title, string(settingsBytes)); err != nil {
					stepLogger.Printf("Failed to update step %d: %v", existingStep.ID, err)
				} else {
					stepLogger.Printf("Updated step %d for criterion %s", existingStep.ID, criterion.Title)
				}
			}
			// Remove from map so we can later identify obsolete steps.
			delete(existingStepsByCriterionID, criterion.Title)
		} else {
			// Step doesn't exist, create it.
			wrappedSettings := map[string]models.RubricShellConfig{"rubric_shell": rubricShellSettings}
			settingsBytes, _ := json.Marshal(wrappedSettings)
			newStepID, err := models.CreateStep(db, strconv.Itoa(stepExec.TaskID), title, string(settingsBytes))
			if err != nil {
				stepLogger.Printf("Failed to create new step for criterion %s: %v", criterion.Title, err)
			} else {
				stepLogger.Printf("Created new step %d for criterion %s", newStepID, criterion.Title)
			}
		}
	}

	// 5. Delete obsolete steps (those still left in the map).
	if len(existingStepsByCriterionID) > 0 {
		stepLogger.Printf("Deleting %d obsolete steps.", len(existingStepsByCriterionID))
		for _, step := range existingStepsByCriterionID {
			if err := models.DeleteStep(db, step.ID); err != nil {
				stepLogger.Printf("Failed to delete obsolete step %d: %v", step.ID, err)
			} else {
				stepLogger.Printf("Deleted obsolete step %d.", step.ID)
			}
		}
	}

	// 6. Update the hashes in the parent rubric_set step's settings.
	config.Hashes = newHashes
	wrappedSettings := map[string]models.RubricSetConfig{"rubric_set": *config}
	newSettingsBytes, err := json.Marshal(wrappedSettings)
	if err != nil {
		return fmt.Errorf("failed to marshal updated settings: %w", err)
	}
	if err := models.UpdateStep(db, stepExec.StepID, stepExec.Title, string(newSettingsBytes)); err != nil {
		return fmt.Errorf("failed to update rubric_set step with new hashes: %w", err)
	}

	stepLogger.Println("Successfully processed rubric_set step.")
	return nil
}
