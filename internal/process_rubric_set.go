package internal

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strconv"

	"github.com/PortNumber53/task-sync/pkg/models"
)

// processAllRubricSetSteps finds and executes all rubric_set steps.
func processAllRubricSetSteps(db *sql.DB, logger *log.Logger) error {
	// Query for all steps of type 'rubric_set'.
	// We identify them by the presence of the 'rubric_set' key in their settings.
	query := `
		SELECT s.id, s.task_id, s.title, s.settings, t.local_path
		FROM steps s
		JOIN tasks t ON s.task_id = t.id
		WHERE s.settings ? 'rubric_set'
	`
	rows, err := db.Query(query)
	if err != nil {
		return fmt.Errorf("failed to query for rubric_set steps: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		var stepExec models.StepExec
		if err := rows.Scan(&stepExec.StepID, &stepExec.TaskID, &stepExec.Title, &stepExec.Settings, &stepExec.LocalPath); err != nil {
			logger.Printf("failed to scan rubric_set step: %v", err)
			continue
		}

		// Create a logger for this specific step instance.
		stepLogger := log.New(os.Stdout, fmt.Sprintf("STEP %d [rubric_set]: ", stepExec.StepID), log.Ldate|log.Ltime|log.Lshortfile)

		// Call the original processor for the individual step.
		if err := ProcessRubricSetStep(db, &stepExec, stepLogger); err != nil {
			logger.Printf("failed to process rubric_set step %d: %v", stepExec.StepID, err)
			// Continue processing other steps even if one fails.
		}
	}

	return nil
}

// ProcessRubricSetStep handles the execution of a rubric_set step.
// It reads a Markdown file, parses rubric criteria, and creates new rubric_shell steps.
func ProcessRubricSetStep(db *sql.DB, stepExec *models.StepExec, stepLogger *log.Logger) error {
	stepLogger.Printf("Raw settings string: %s", stepExec.Settings)

	var settings struct {
		RubricSet models.RubricSetConfig `json:"rubric_set"`
	}

	if err := json.Unmarshal([]byte(stepExec.Settings), &settings); err != nil {
		return fmt.Errorf("failed to unmarshal step settings: %w", err)
	}

	if settings.RubricSet.MarkdownFile == "" {
		return fmt.Errorf("markdown file path is not specified in the rubric_set settings")
	}
	stepLogger.Printf("Config MarkdownFile: '%s'", settings.RubricSet.MarkdownFile)

	// The file path in settings is relative to the task's local path.
	markdownFilePath := filepath.Join(stepExec.LocalPath, settings.RubricSet.MarkdownFile)
	stepLogger.Printf("Attempting to parse rubric file at path: %s", markdownFilePath)

	if _, err := os.Stat(markdownFilePath); os.IsNotExist(err) {
		return fmt.Errorf("rubric file does not exist at path: %s", markdownFilePath)
	}

	criteria, err := models.ParseRubric(markdownFilePath)
	if err != nil {
		return fmt.Errorf("failed to parse rubric markdown: %w", err)
	}
	stepLogger.Printf("Found %d criteria in %s", len(criteria), markdownFilePath)

	// Fetch existing steps generated by this rubric_set step.
	existingSteps, err := models.GetGeneratedSteps(db, int(stepExec.StepID))
	if err != nil {
		return fmt.Errorf("failed to get existing generated steps: %w", err)
	}
	stepLogger.Printf("Found %d existing generated steps.", len(existingSteps))

	// If there are no criteria, there's nothing to do.
	if len(criteria) == 0 {
		stepLogger.Printf("No criteria found in the rubric file, nothing to do.")
		// Potentially delete all existing steps if that's the desired behavior
		return nil
	}

	// Group existing steps by their criterion ID.
	existingStepsByCriterion := make(map[string][]models.StepExec)
	for _, step := range existingSteps {
		var stepSettings models.RubricShellConfig
		var wrapped map[string]json.RawMessage
		if err := json.Unmarshal([]byte(step.Settings), &wrapped); err == nil && wrapped["rubric_shell"] != nil {
			if err := json.Unmarshal(wrapped["rubric_shell"], &stepSettings); err != nil {
				stepLogger.Printf("failed to unmarshal nested rubric_shell settings for step %d, skipping: %v", step.StepID, err)
				continue
			}
		} else {
			stepLogger.Printf("Step %d has malformed settings, skipping: %v", step.StepID, err)
			continue
		}

		if stepSettings.CriterionID != "" {
			existingStepsByCriterion[stepSettings.CriterionID] = append(existingStepsByCriterion[stepSettings.CriterionID], step)
		} else {
			stepLogger.Printf("Step %d has no CriterionID, skipping.", step.StepID)
		}
	}
	stepLogger.Printf("Grouped %d existing steps into %d buckets by criterion ID.", len(existingSteps), len(existingStepsByCriterion))

	keptStepIDs := make(map[int]bool)

	// Process criteria from the file, updating one step per criterion and marking it as kept.
	for _, criterion := range criteria {
		title := fmt.Sprintf("Rubric %s: %s", criterion.Counter, criterion.Title)
		rubricShellSettings := models.RubricShellConfig{
			Command:     criterion.HeldOutTest,
			CriterionID: criterion.Title,
			Counter:     criterion.Counter,
			Score:       criterion.Score,
			Required:    criterion.Required,
			DependsOn:   []models.Dependency{{ID: int(stepExec.StepID)}},
			GeneratedBy: strconv.Itoa(int(stepExec.StepID)),
		}

		if stepsForCriterion, ok := existingStepsByCriterion[criterion.Title]; ok && len(stepsForCriterion) > 0 {
			// Update the first step and mark it as kept.
			stepToUpdate := stepsForCriterion[0]
			keptStepIDs[stepToUpdate.StepID] = true

			var existingSettings models.RubricShellConfig
			var wrapped map[string]json.RawMessage
			if err := json.Unmarshal([]byte(stepToUpdate.Settings), &wrapped); err == nil && wrapped["rubric_shell"] != nil {
				_ = json.Unmarshal(wrapped["rubric_shell"], &existingSettings)
			}

			needsUpdate := stepToUpdate.Title != title ||
				existingSettings.Command != rubricShellSettings.Command ||
				existingSettings.Score != rubricShellSettings.Score ||
				existingSettings.Required != rubricShellSettings.Required

			if needsUpdate {
				wrappedSettings := map[string]models.RubricShellConfig{"rubric_shell": rubricShellSettings}
				settingsBytes, _ := json.Marshal(wrappedSettings)
				if err := models.UpdateStep(db, stepToUpdate.StepID, title, string(settingsBytes)); err != nil {
					stepLogger.Printf("Failed to update step %d: %v", stepToUpdate.StepID, err)
				} else {
					stepLogger.Printf("Updated step %d for criterion %s", stepToUpdate.StepID, criterion.Title)
				}
			}
		} else {
			// Create a new step.
			wrappedSettings := map[string]models.RubricShellConfig{"rubric_shell": rubricShellSettings}
			settingsBytes, _ := json.Marshal(wrappedSettings)
			newStepID, err := models.CreateStep(db, strconv.Itoa(stepExec.TaskID), title, string(settingsBytes))
			if err != nil {
				stepLogger.Printf("Failed to create new step for criterion %s: %v", criterion.Title, err)
			} else {
				stepLogger.Printf("Created new step %d for criterion %s", newStepID, criterion.Title)
			}
		}
	}

	// Delete all steps that were not marked as kept.
	deletedCount := 0
	for _, step := range existingSteps {
		if _, isKept := keptStepIDs[step.StepID]; !isKept {
			if err := models.DeleteStep(db, step.StepID); err != nil {
				stepLogger.Printf("Failed to delete obsolete step %d: %v", step.StepID, err)
			} else {
				deletedCount++
			}
		}
	}
	stepLogger.Printf("Deleted %d obsolete steps.", deletedCount)

	return nil
}
