package internal

import (
	"crypto/sha256"
	"database/sql"
	"encoding/hex"
	"fmt"
	"io"
	"log"
	"os"

	"github.com/lib/pq"
)

// StepExec is a private struct used for handling step execution data.
type StepExec struct {
	StepID    int
	TaskID    int
	Title     string
	Settings  string
	LocalPath string
}

// DynamicRubricEnvironment defines the execution environment for generated steps.
type DynamicRubricEnvironment struct {
	Docker   bool   `json:"docker"`
	ImageTag string `json:"image_tag"`
	ImageID  string `json:"image_id"`
}

// DynamicRubricConfig represents the configuration for a dynamic_rubric step
type DynamicRubricConfig struct {
	DynamicRubric struct {
		Rubrics     string                 `json:"rubrics"`
		Hash        string                 `json:"hash,omitempty"`
		Files       map[string]string      `json:"files,omitempty"`
		Hashes      map[string]string      `json:"hashes,omitempty"`
		DependsOn   []Dependency           `json:"depends_on,omitempty"`
		Environment DynamicRubricEnvironment `json:"environment,omitempty"`
	} `json:"dynamic_rubric"`
}

// getSHA256 calculates the SHA256 hash of a file.
func getSHA256(filePath string) (string, error) {
	file, err := os.Open(filePath)
	if err != nil {
		// Handle file not found gracefully
		if os.IsNotExist(err) {
			return "", nil // Return empty hash and no error if file doesn't exist
		}
		return "", fmt.Errorf("failed to open file for hashing: %w", err)
	}
	defer file.Close()

	hasher := sha256.New()
	if _, err := io.Copy(hasher, file); err != nil {
		return "", fmt.Errorf("failed to copy file content to hasher: %w", err)
	}

	return hex.EncodeToString(hasher.Sum(nil)), nil
}

func generatedStepsExist(db *sql.DB, parentStepID int) (bool, error) {
	var count int
	// Check for steps generated by the parent step by looking inside the settings JSON.
	query := `SELECT COUNT(*) FROM steps WHERE (settings->'docker_shell'->>'generated_by')::int = $1`
	err := db.QueryRow(query, parentStepID).Scan(&count)
	if err != nil {
		return false, fmt.Errorf("failed to query for generated steps: %w", err)
	}
	return count > 0, nil
}

func deleteGeneratedSteps(db *sql.DB, parentStepID int, runStepDependencyID int) error {
	// Find steps that were generated by the parent step
	query := `
		SELECT id FROM steps WHERE 
		-- New way: step is explicitly generated by the parent
		(settings->'docker_shell'->>'generated_by')::int = $1 OR
		-- Old way: step depends on the same container and has a crit- title
		(title LIKE 'crit-%' AND settings->'docker_shell'->'depends_on' @> jsonb_build_array(jsonb_build_object('id', $2::int)))
	`
	rows, err := db.Query(query, parentStepID, runStepDependencyID)
	if err != nil {
		return fmt.Errorf("querying for generated steps failed: %w", err)
	}
	defer rows.Close()

	var idsToDelete []int
	for rows.Next() {
		var id int
		if err := rows.Scan(&id); err != nil {
			return fmt.Errorf("scanning generated step id failed: %w", err)
		}
		idsToDelete = append(idsToDelete, id)
	}

	if len(idsToDelete) > 0 {
		deleteQuery := `DELETE FROM steps WHERE id = ANY($1::int[])`
		_, err := db.Exec(deleteQuery, pq.Array(idsToDelete))
		if err != nil {
			return fmt.Errorf("deleting generated steps failed: %w", err)
		}
		log.Printf("Deleted %d generated steps for parent step %d", len(idsToDelete), parentStepID)
	}

	return nil
}

func getStepsByType(db *sql.DB, stepType string) ([]StepExec, error) {
	query := `
		SELECT s.id, s.task_id, s.title, s.settings, COALESCE(t.local_path, '')
		FROM steps s
		JOIN tasks t ON s.task_id = t.id
		WHERE s.settings ? $1`

	rows, err := db.Query(query, stepType)
	if err != nil {
		return nil, fmt.Errorf("querying for steps by type failed: %w", err)
	}
	defer rows.Close()

	var steps []StepExec
	for rows.Next() {
		var step StepExec
		if err := rows.Scan(&step.StepID, &step.TaskID, &step.Title, &step.Settings, &step.LocalPath); err != nil {
			return nil, fmt.Errorf("scanning step failed: %w", err)
		}
		steps = append(steps, step)
	}

	return steps, nil
}
