package models

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"strconv"
)

// StepExec holds the necessary information for executing a step.
// It's populated from a database query joining steps and tasks.
type StepExec struct {
	StepID    int
	TaskID    int
	Title     string
	Settings  string
	LocalPath string
}

// DependencyHolder is a helper struct for unmarshaling nested dependencies
type DependencyHolder struct {
	DependsOn []Dependency `json:"depends_on,omitempty"`
}

// StepConfigHolder holds all possible step configurations.
type StepConfigHolder struct {
	RubricShell          *RubricShellConfig          `json:"rubric_shell,omitempty"`
	RubricSet            *RubricSetConfig            `json:"rubric_set,omitempty"`
	DockerRun            *DockerRunConfig            `json:"docker_run,omitempty"`
	DockerPool           *DockerPoolConfig           `json:"docker_pool,omitempty"`
	DockerBuild          *DockerBuildConfig          `json:"docker_build,omitempty"`
	DockerShell          *DockerShellConfig          `json:"docker_shell,omitempty"`
	DockerVolumePool     *DockerVolumePoolConfig     `json:"docker_volume_pool,omitempty"`
}

// StepConfig is an interface that all step configurations should implement.
type StepConfig interface {
	GetImageTag() string
	GetImageID() string
	HasImage() bool
	GetDependsOn() []Dependency
}

// GetConfig returns the non-nil configuration from the holder.
func (h *StepConfigHolder) GetConfig() (StepConfig, error) {
	if h.RubricShell != nil {
		return h.RubricShell, nil
	}
	if h.RubricSet != nil {
		return h.RubricSet, nil
	}
	return nil, fmt.Errorf("no configuration found in StepConfigHolder")
}

// AllDependencies collects and returns all `depends_on` entries from the held configurations.
func (h *StepConfigHolder) AllDependencies() []Dependency {
	var deps []Dependency
	if h.RubricShell != nil {
		deps = append(deps, h.RubricShell.DependsOn...)
	}
	if h.RubricSet != nil {
		deps = append(deps, h.RubricSet.DependsOn...)
	}
	return deps
}

// --- Detail Structs ---

// StepNode represents a step in a task for tree display.
type StepNode struct {
	ID       int
	Title    string
	TaskID   int
	Children []*StepNode
}

// UpdateStepSettings updates the settings of a specific step.
func UpdateStepSettings(db *sql.DB, stepID int, settings string) error {
	query := `UPDATE steps SET settings = $1, updated_at = NOW() WHERE id = $2`
	_, err := db.Exec(query, settings, stepID)
	if err != nil {
		return fmt.Errorf("failed to update settings for step %d: %w", stepID, err)
	}
	return nil
}

// ClearStepResults clears the results for a step
func ClearStepResults(db *sql.DB, stepID int) error {
	result, err := db.Exec(
		"UPDATE steps SET results = NULL, updated_at = NOW() WHERE id = $1",
		stepID,
	)
	if err != nil {
		return fmt.Errorf("failed to clear results for step %d: %w", stepID, err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to check rows affected for step %d: %w", stepID, err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("no step found with ID %d", stepID)
	}

	return nil
}

// StoreStepResult stores the execution result of a step
func StoreStepResult(db *sql.DB, stepID int, result map[string]interface{}) error {
	resJson, _ := json.Marshal(result)
	resultExec, err := db.Exec(`UPDATE steps SET results = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2`, string(resJson), stepID)
	if err != nil {
		return fmt.Errorf("failed to update results for step %d: %w", stepID, err)
	}
	rowsAffected, err := resultExec.RowsAffected()
	if err != nil {
		return fmt.Errorf("error checking affected rows: %w", err)
	}
	if rowsAffected == 0 {
		return fmt.Errorf("no step found with ID %d", stepID)
	}
	return nil
}

// GetGeneratedSteps retrieves all steps generated by a specific parent step.
func GetGeneratedSteps(db *sql.DB, generatedByStepID int) ([]Step, error) {
	query := `
		SELECT id, task_id, title, settings, results, created_at, updated_at
		FROM steps
		WHERE (settings->'rubric_shell'->>'generated_by' = $1)
	`
	rows, err := db.Query(query, strconv.Itoa(generatedByStepID))
	if err != nil {
		return nil, fmt.Errorf("failed to query for generated steps for %d: %w", generatedByStepID, err)
	}
	defer rows.Close()

	var steps []Step
	for rows.Next() {
		var s Step
		var results sql.NullString
		if err := rows.Scan(&s.ID, &s.TaskID, &s.Title, &s.Settings, &results, &s.CreatedAt, &s.UpdatedAt); err != nil {
			return nil, fmt.Errorf("failed to scan generated step: %w", err)
		}
		s.Results = results.String
		steps = append(steps, s)
	}
	return steps, nil
}

// DeleteGeneratedSteps deletes steps that were generated by another step.
func DeleteGeneratedSteps(db *sql.DB, generatedByStepID int) error {
	// This query targets steps where the 'generated_by' key matches the parent step ID.
	// It handles both nested (e.g., in 'rubric_shell') and top-level 'generated_by' fields.
	query := `DELETE FROM steps WHERE (settings->'rubric_shell'->>'generated_by' = $1) OR (settings->>'generated_by' = $1)`
	_, err := db.Exec(query, strconv.Itoa(generatedByStepID))
	if err != nil {
		return fmt.Errorf("failed to delete generated steps for %d: %w", generatedByStepID, err)
	}
	return nil
}

// GeneratedStepsExist checks if there are any steps generated by a given step.
func GeneratedStepsExist(db *sql.DB, generatedByStepID int) (bool, error) {
	var exists bool
	// This query checks for the existence of steps where the 'generated_by' key matches the parent step ID.
	// It handles both nested (e.g., in 'rubric_shell') and top-level 'generated_by' fields.
	query := `SELECT EXISTS(SELECT 1 FROM steps WHERE (settings->'rubric_shell'->>'generated_by' = $1) OR (settings->>'generated_by' = $1))`
	err := db.QueryRow(query, strconv.Itoa(generatedByStepID)).Scan(&exists)
	if err != nil {
		return false, fmt.Errorf("failed to check for generated steps for %d: %w", generatedByStepID, err)
	}
	return exists, nil
}

// Step represents a single step in a task, holding its core attributes.
type Step struct {
	ID        int
	TaskID    int
	Title     string
	Settings  string
	Results   string
	CreatedAt string
	UpdatedAt string
}

// RubricShellConfig represents the configuration for a rubric_shell step.
type RubricShellConfig struct {
	ImageID          string            `json:"image_id,omitempty"`
	ImageTag         string            `json:"image_tag,omitempty"`
	Command          string            `json:"command"`
	CriterionID      string            `json:"criterion_id,omitempty"`
	Counter          string            `json:"counter,omitempty"`
	Score            int               `json:"score,omitempty"`
	Required         bool              `json:"required,omitempty"`
	DependsOn        []Dependency      `json:"depends_on,omitempty"`
	GeneratedBy      string            `json:"generated_by,omitempty"`
	ContainerName    string            `json:"container_name,omitempty"`
	LastRun          map[string]string `json:"last_run,omitempty"`
	Files            map[string]string `json:"files,omitempty"`
	Rerun            bool              `json:"rerun,omitempty"`
}

func (c *RubricShellConfig) GetImageTag() string      { return c.ImageTag }
func (c *RubricShellConfig) GetImageID() string       { return c.ImageID }
func (c *RubricShellConfig) HasImage() bool           { return c.ImageTag != "" && c.ImageID != "" }
func (c *RubricShellConfig) GetDependsOn() []Dependency { return c.DependsOn }

// RubricSetConfig represents the configuration for a rubric_set step.
// - File: the main rubric markdown file
// - Files: additional files to track for hash changes (name->relative path)
// - Hashes: map of filename to last known SHA256 hash
// When any file's hash changes, the step should re-run.
type RubricSetConfig struct {
	File             string            `json:"file"`
	Files            map[string]string `json:"files,omitempty"`
	HeldOutTest      string            `json:"held_out_test,omitempty"`
	Solution1        string            `json:"solution_1,omitempty"`
	Solution2        string            `json:"solution_2,omitempty"`
	Solution3        string            `json:"solution_3,omitempty"`
	Solution4        string            `json:"solution_4,omitempty"`
	DependsOn        []Dependency      `json:"depends_on,omitempty"`
}

func (c *RubricSetConfig) GetImageTag() string      { return "" }
func (c *RubricSetConfig) GetImageID() string       { return "" }
func (c *RubricSetConfig) HasImage() bool           { return false }
func (c *RubricSetConfig) GetDependsOn() []Dependency { return c.DependsOn }

// DockerVolumePoolConfig represents the configuration for a docker_volume_pool step.
type DockerVolumePoolConfig struct {
	Triggers struct {
		Files map[string]string `json:"files"`
		ImageID string `json:"image_id"`
		ImageTag string `json:"image_tag"`
		Containers map[string]string `json:"containers"`
	} `json:"triggers"`
	Artifacts map[string]interface{} `json:"artifacts"`
	PoolSize int `json:"pool_size"`
	DependsOn []map[string]int `json:"depends_on"`
	Parameters []string `json:"parameters"`
	ImageTag string `json:"image_tag"`
	ContainerFolder string `json:"container_folder"`
	Solutions []string `json:"solutions"`
	HeldOutTestFile string `json:"held_out_test_file"`
	GradingSetupScript string `json:"grading_setup_script"`
	KeepForever bool `json:"keep_forever"`
	Force bool `json:"force"`
}

// stepLogger is a global logger for step-related messages.
var StepLogger *log.Logger

// stepExec is a global variable that holds the necessary information for executing a step.
// It's populated from a database query joining steps and tasks.
