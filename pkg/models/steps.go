package models

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
)

// StepExec holds the necessary information for executing a step.
// It's populated from a database query joining steps and tasks.
type StepExec struct {
	StepID    int
	TaskID    int
	Title     string
	Settings  string
	BasePath string
}

// DependencyHolder is a helper struct for unmarshaling nested dependencies
type DependencyHolder struct {
	DependsOn []Dependency `json:"depends_on,omitempty"`
}

// StepConfigHolder holds all possible step configurations.
type StepConfigHolder struct {
	RubricShell      *RubricShellConfig      `json:"rubric_shell,omitempty"`
	DynamicRubric    *DynamicRubricConfig    `json:"dynamic_rubric,omitempty"`
	RubricSet        *RubricSetConfig        `json:"rubric_set,omitempty"`
	DockerRun        *DockerRunConfig        `json:"docker_run,omitempty"`
	DockerPool       *DockerPoolConfig       `json:"docker_pool,omitempty"`
	DockerBuild      *DockerBuildConfig      `json:"docker_build,omitempty"`
	DockerShell      *DockerShellConfig      `json:"docker_shell,omitempty"`
	DockerVolumePool *DockerVolumePoolConfig `json:"docker_volume_pool,omitempty"`
	ModelTaskCheck   *ModelTaskCheckConfig   `json:"model_task_check,omitempty"`
}

// StepConfig is an interface that all step configurations should implement.
type StepConfig interface {
	GetImageTag() string
	GetImageID() string
	HasImage() bool
	GetDependsOn() []Dependency
}

// GetConfig returns the non-nil configuration from the holder.
func (h *StepConfigHolder) GetConfig() (StepConfig, error) {
	if h.RubricShell != nil {
		return h.RubricShell, nil
	}
	if h.DynamicRubric != nil {
		return h.DynamicRubric, nil
	}
	if h.RubricSet != nil {
		return h.RubricSet, nil
	}
	if h.ModelTaskCheck != nil {
		return h.ModelTaskCheck, nil
	}
	return nil, fmt.Errorf("no configuration found in StepConfigHolder")
}

// AllDependencies collects and returns all `depends_on` entries from the held configurations.
func (h *StepConfigHolder) AllDependencies() []Dependency {
	var deps []Dependency
	if h.RubricShell != nil {
		deps = append(deps, h.RubricShell.DependsOn...)
	}
	if h.DynamicRubric != nil {
		deps = append(deps, h.DynamicRubric.DynamicRubric.DependsOn...)
	}
	if h.RubricSet != nil {
		deps = append(deps, h.RubricSet.DependsOn...)
	}
	if h.ModelTaskCheck != nil {
		deps = append(deps, h.ModelTaskCheck.DependsOn...)
	}
	return deps
}

// --- Detail Structs ---

// StepNode represents a step in a task for tree display.
type StepNode struct {
	ID       int
	Title    string
	TaskID   int
	Children []*StepNode
}

// UpdateStepSettings updates the settings of a specific step.
func UpdateStepSettings(db *sql.DB, stepID int, settings string) error {
	query := `UPDATE steps SET settings = $1, updated_at = NOW() WHERE id = $2`
	_, err := db.Exec(query, settings, stepID)
	if err != nil {
		return fmt.Errorf("failed to update settings for step %d: %w", stepID, err)
	}
	return nil
}

// ClearStepResults clears the results for a step
func ClearStepResults(db *sql.DB, stepID int) error {
	result, err := db.Exec(
		"UPDATE steps SET results = NULL, updated_at = NOW() WHERE id = $1",
		stepID,
	)
	if err != nil {
		return fmt.Errorf("failed to clear results for step %d: %w", stepID, err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to check rows affected for step %d: %w", stepID, err)
	}

	if rowsAffected == 0 {
		return fmt.Errorf("no step found with ID %d", stepID)
	}

	return nil
}

// StoreStepResult stores the execution result of a step
func StoreStepResult(db *sql.DB, stepID int, result map[string]interface{}) error {
	resJson, _ := json.Marshal(result)
	resultExec, err := db.Exec(`UPDATE steps SET results = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2`, string(resJson), stepID)
	if err != nil {
		return fmt.Errorf("failed to update results for step %d: %w", stepID, err)
	}
	rowsAffected, err := resultExec.RowsAffected()
	if err != nil {
		return fmt.Errorf("error checking affected rows: %w", err)
	}
	if rowsAffected == 0 {
		return fmt.Errorf("no step found with ID %d", stepID)
	}
	return nil
}

// GetGeneratedSteps retrieves all rubric_shell steps generated by a specific parent step.
func GetGeneratedSteps(db *sql.DB, generatedByStepID int) ([]Step, error) {
	query := `
		SELECT id, task_id, title, settings, results, created_at, updated_at
		FROM steps
		WHERE (settings->'rubric_shell'->>'generated_by')::int = $1
	`
	rows, err := db.Query(query, generatedByStepID)
	if err != nil {
		return nil, fmt.Errorf("failed to query generated steps for parent %d: %w", generatedByStepID, err)
	}
	defer rows.Close()

	var steps []Step
	for rows.Next() {
		var step Step
		var results sql.NullString
		if err := rows.Scan(&step.ID, &step.TaskID, &step.Title, &step.Settings, &results, &step.CreatedAt, &step.UpdatedAt); err != nil {
			return nil, fmt.Errorf("failed to scan generated step row: %w", err)
		}
		step.Results = results.String
		steps = append(steps, step)
	}

	return steps, nil
}

// DeleteGeneratedSteps deletes rubric_shell steps generated by another step.
func DeleteGeneratedSteps(db *sql.DB, generatedByStepID int) error {
	query := `DELETE FROM steps WHERE (settings->'rubric_shell'->>'generated_by')::int = $1`
	_, err := db.Exec(query, generatedByStepID)
	if err != nil {
		return fmt.Errorf("failed to delete generated steps for parent step %d: %w", generatedByStepID, err)
	}
	return nil
}

// GeneratedStepsExist checks if there are any rubric_shell steps generated by a given step.
func GeneratedStepsExist(db *sql.DB, generatedByStepID int) (bool, error) {
	var exists bool
	query := `SELECT EXISTS(SELECT 1 FROM steps WHERE (settings->'rubric_shell'->>'generated_by')::int = $1)`
	err := db.QueryRow(query, generatedByStepID).Scan(&exists)
	if err != nil {
		return false, fmt.Errorf("failed to check for generated steps for parent %d: %w", generatedByStepID, err)
	}
	return exists, nil
}

// Step represents a single step in a task, holding its core attributes.
type Step struct {
	ID        int    `json:"id"`
	TaskID    int    `json:"task_id"`
	Title     string `json:"title"`
	Settings  string `json:"settings"`
	BasePath  string `json:"base_path,omitempty"`
	Results   string `json:"results"`
	CreatedAt string `json:"created_at"`
	UpdatedAt string `json:"updated_at"`
}

// RubricShellAssignment defines a pairing of a solution patch and a container.
type RubricShellAssignment struct {
	Patch     string `json:"patch"`
	Container string `json:"container"`
}

// RubricShellConfig represents the configuration for a rubric_shell step.
type RubricShellConfig struct {
	ImageID     string                  `json:"image_id,omitempty"`
	ImageTag    string                  `json:"image_tag,omitempty"`
	Command     string                  `json:"command"`
	CriterionID string                  `json:"criterion_id,omitempty"`
	Counter     string                  `json:"counter,omitempty"`
	Score       int                     `json:"score,omitempty"`
	Required    bool                    `json:"required,omitempty"`
	Rubric      string                  `json:"rubric"`
	DependsOn   []Dependency            `json:"depends_on,omitempty"`
	GeneratedBy string                  `json:"generated_by,omitempty"`
	Assignments []RubricShellAssignment `json:"assignments,omitempty"`
	LastRun     map[string]string       `json:"last_run,omitempty"`
	Files       map[string]string       `json:"files,omitempty"`
	Rerun       bool                    `json:"rerun,omitempty"`
	Triggers    Triggers                `json:"triggers,omitempty"`
	HashLastRun string                  `json:"hash_last_run,omitempty"`
}

func (c *RubricShellConfig) GetImageTag() string      { return c.ImageTag }
func (c *RubricShellConfig) GetImageID() string       { return c.ImageID }
func (c *RubricShellConfig) HasImage() bool           { return c.ImageTag != "" && c.ImageID != "" }
func (c *RubricShellConfig) GetDependsOn() []Dependency { return c.DependsOn }

// DynamicRubricConfig is the top-level configuration for a dynamic_rubric step.
type DynamicRubricConfig struct {
	DynamicRubric DynamicRubric `json:"dynamic_rubric"`
}

// DynamicRubric holds the specific settings for the dynamic rubric logic.
type DynamicRubric struct {
	Files            map[string]string `json:"files,omitempty"`
	Rubrics          []string          `json:"rubrics,omitempty"`
	Hash             string            `json:"hash,omitempty"`
	AssignContainers map[string]string `json:"assign_containers,omitempty"`
	Environment      struct {
		Docker   bool   `json:"docker"`
		ImageID  string `json:"image_id,omitempty"`
		ImageTag string `json:"image_tag,omitempty"`
	} `json:"environment"`
	DependsOn []Dependency `json:"depends_on,omitempty"`
}

func (c *DynamicRubricConfig) GetImageTag() string      { return c.DynamicRubric.Environment.ImageTag }
func (c *DynamicRubricConfig) GetImageID() string       { return c.DynamicRubric.Environment.ImageID }
func (c *DynamicRubricConfig) HasImage() bool           { return c.DynamicRubric.Environment.ImageID != "" && c.DynamicRubric.Environment.ImageTag != "" }
func (c *DynamicRubricConfig) GetDependsOn() []Dependency { return c.DynamicRubric.DependsOn }

// RubricSetConfig represents the configuration for a rubric_set step.
type RubricSetConfig struct {
	File        string            `json:"file"`
	Files       map[string]string `json:"files"`
	HeldOutTest string            `json:"held_out_test,omitempty"`
	DependsOn   []Dependency      `json:"depends_on,omitempty"`
}

func (c *RubricSetConfig) GetImageTag() string      { return "" }
func (c *RubricSetConfig) GetImageID() string       { return "" }
func (c *RubricSetConfig) HasImage() bool           { return false }
func (c *RubricSetConfig) GetDependsOn() []Dependency { return c.DependsOn }

// Triggers defines what events should trigger a step re-run.
type Triggers struct {
	Files map[string]string `json:"files,omitempty"`
}

// DockerVolumePoolConfig represents the configuration for a docker_volume_pool step.
type DockerVolumePoolConfig struct {
	Triggers struct {
		Files map[string]string `json:"files"`
		ImageID string `json:"image_id"`
		ImageTag string `json:"image_tag"`
		Containers map[string]string `json:"containers"`
	} `json:"triggers"`
	Artifacts map[string]interface{} `json:"artifacts,omitempty"`
	PoolSize int `json:"pool_size,omitempty"`
	DependsOn []map[string]int `json:"depends_on"`
	Parameters []string `json:"parameters"`
	ImageTag string `json:"image_tag"`
	ContainerFolder string `json:"container_folder,omitempty"`
	Solutions []string `json:"solutions,omitempty"`
	HeldOutTestFile string `json:"held_out_test_file"`
	GradingSetupScript string `json:"grading_setup_script"`
	KeepForever bool `json:"keep_forever"`
	Force bool `json:"force"`
	Golden bool `json:"golden,omitempty"`
	Original bool `json:"original,omitempty"`
}

// stepLogger is a global logger for step-related messages.
var StepLogger *log.Logger

// stepExec is a global variable that holds the necessary information for executing a step.
// It's populated from a database query joining steps and tasks.
